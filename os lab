1a)FCFS
#include<stdio.h>
void findavgTime(int bt[],int n)
{
int wt[10];
int tat[10];
int total_wt=0,total_tat=0;
int i;
wt[0]=0;
for(i=1;i<n;i++)
wt[i]=bt[i-1]+wt[i-1];
for(i=0;i<n;i++)
tat[i]=bt[i]+wt[i];
printf("Processes    Burst time    Waiting time      Turn around time\n");
for(i=0;i<n;i++)
{
total_wt+=wt[i];
total_tat+=tat[i];
printf("   %d            %d             %d                 %d\n",i+1,bt[i],wt[i],tat[i]);
}
printf("Avg. waiting time = %.2f\n",(float)total_wt/n);
printf("Avg. turn around time = %.2f\n",(float)total_tat/n);
}
void main()
{
int burst_time[]={4,13,6};
int n=sizeof burst_time/sizeof burst_time[0];
clrscr();
findavgTime(burst_time,n);
getch();
}


1b)SJF
//non-preemptive
#include<stdio.h>
void main()
{
int A[100][4],n,total=0;
int i,j,k,index;
float avg_wt,avg_tat;
clrscr();
printf("Enter no. of processes: ");
scanf("%d",&n);
printf("Enter burst time:\n");
for(i=0;i<n;i++)
{
printf("P%d: ",i+1);
scanf("%d",&A[i][1]);
A[i][0]=i+1;
}
for(i=0;i<n;i++)
{
index=i;
for(j=i+1;j<n;j++)
if(A[j][1] < A[index][1])
index=j;
for(k=0;k<2;k++)
{
int temp=A[i][k];
A[i][k] = A[index][k];
A[index][k] = temp;
}
}
A[0][2]=0;
for(i=1;i<n;i++)
{
A[i][2]=A[i-1][2] + A[i-1][1];
total += A[i][2];
}
avg_wt = (float)total/n;
total=0;
printf("P\tBT\tWT\tTAT\n");
for(i=0;i<n;i++)
{
A[i][3]=A[i][1]+A[i][2];
total += A[i][3];
printf("P%d\t%d\t%d\t%d\n",A[i][0],A[i][1],A[i][2],A[i][3]);
}
avg_tat = (float)total/n;
printf("Avg WT= %.2f\nAvg TAT= %.2f\n",avg_wt,avg_tat);
getch();
}
//preemptive
#include<stdio.h>
#include<limits.h>
void main()
{
int pid[]={1,2,3,4,5}, bt[]={3,2,9,10,4}, art[]={6,1,4,8,2};
int n=sizeof(pid)/sizeof(pid[0]),wt[10],tat[10],rt[10];
int i,j,t,complete;
int total_wt=0,total_tat=0;
clrscr();
for(i=0;i<n;i++)
rt[i]=bt[i];
for(complete=0,t=0;complete<n;t++)
{
int minm = INT_MAX, check=0,shortest;
for(j=0;j<n;j++)
{
if(art[j] <= t && rt[j] < minm && rt[j] > 0)
{
minm = rt[j];
shortest = j;
check=1;
}
}
if(!check) continue;
if(--rt[shortest]==0)
{
wt[shortest]=t+1-bt[shortest]-art[shortest];
if(wt[shortest]<0)
wt[shortest]=0;
complete++;
}
}
for(i=0;i<n;i++)
tat[i]=bt[i]+wt[i];
printf("P\tBT\tWT\tTAT\n");
for(i=0;i<n;i++)
{
total_wt += wt[i];
total_tat += tat[i];
printf("%d\t%d\t%d\t%d\n",pid[i],bt[i],wt[i],tat[i]);
}
printf("Avg WT = %.2f\nAvg TAT=%.2f\n",(float)total_wt/n,(float)total_tat/n);
getch();
}


1c)Priority
//Non-preemptive
#include<stdio.h>
#include<conio.h>
void main()
{
int i,j,n,tat[10],wt[10],bt[10],pid[10],pr[10],t,twt=0,ttat=0;
float awt,atat;
clrscr();
printf("Enter the no. of processes:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
pid[i]=i;
printf("Enter the Burst Time of Process-%d:",i+1);
scanf("%d",&bt[i]);
printf("Enter the Priority of Process-%d:",i+1);
scanf("%d",&pr[i]);
}
for(i=0;i<n;i++)
for(j=i+1;j<n;j++)
{
if(pr[i]>pr[j])
{
t=pr[i];
pr[i]=pr[j];
pr[j]=t;
t=bt[i];
bt[i]=bt[j];
bt[j]=t;
t=pid[i];
pid[i]=pid[j];
pid[j]=t;
}
}
tat[0]=bt[0];
wt[0]=0;
for(i=1;i<n;i++)
{
wt[i]=wt[i-1]+bt[i-1];
tat[i]=wt[i]+bt[i];
}
printf("\n");
printf("P_ID\tPRIORITY\tBURST_TIME\tWAITING_TIME\tTURN_AROUND_TIME\n");
for(i=0;i<n;i++)
{
printf("\n%d\t%d\t\t%d\t\t%d\t\t%d",((pid[i])+1),pr[i],bt[i],wt[i],tat[i]);
}
for(i=0;i<n;i++)
{
ttat=ttat+tat[i];
twt=twt+wt[i];
}
awt=(float)twt/n;
atat=(float)ttat/n;
printf("\n\nAvg Waiting Time : %f \nAvg Turn Around Time : %f \n",awt,atat);
getch();
}


//Preemptive
#include<stdio.h>
void main()
{
int n, i, j;
int p[30],bt[30],pr[30],at[30],wt[30],tat[30],temp;
float avgWT = 0, avgTAT = 0;
clrscr();
printf("Enter number of processes: ");
scanf("%d", &n);
for (i = 0; i < n; i++) {
p[i] = i + 1;
printf("Enter BT, PR, AT for P%d: \n", p[i]);
scanf("%d %d %d", &bt[i], &pr[i], &at[i]);
}
for (i = 0; i < n - 1; i++)
for (j = i + 1; j < n; j++)
if (at[i] > at[j] || (at[i] == at[j] && pr[i] > pr[j])) {
temp = bt[i]; bt[i] = bt[j]; bt[j] = temp;
temp = pr[i]; pr[i] = pr[j]; pr[j] = temp;
temp = at[i]; at[i] = at[j]; at[j] = temp;
temp = p[i]; p[i] = p[j]; p[j] = temp;
}
wt[0] = 0;
for (i = 1; i < n; i++)
wt[i] = wt[i - 1] + bt[i - 1] - (at[i] - at[i - 1]);
for (i = 0; i < n; i++)
tat[i] = wt[i] + bt[i];
printf("\nPID\tBT\tPR\tAT\tWT\tTAT\n");
for (i = 0; i < n; i++)
printf("%d\t%d\t%d\t%d\t%d\t%d\n", p[i], bt[i], pr[i], at[i], wt[i], tat[i]);
for (i = 0; i < n; i++) {
avgWT += wt[i];
avgTAT += tat[i];
}
printf("\nAvg WT: %.2f", avgWT / n);
printf("\nAvg TAT: %.2f\n", avgTAT / n);
getch();
}

1d)Round robin
#include <stdio.h>
void findWaitingTime(int n, int bt[], int wt[], int quantum)
{
int i, rem_bt[40], t = 0, done;
for (i = 0; i < n; i++) rem_bt[i] = bt[i];
while (1){
done = 1;
for ( i = 0; i < n; i++){
if (rem_bt[i] > 0){
done = 0;
if (rem_bt[i] > quantum) t += quantum, rem_bt[i] -= quantum;
else t += rem_bt[i], wt[i] = t - bt[i], rem_bt[i] = 0;
}
}
if (done) break;
}
}
void findTurnAroundTime(int n, int bt[], int wt[], int tat[]){
int i;
for ( i = 0; i < n; i++) tat[i] = bt[i] + wt[i];}
void findavgTime(int n, int bt[], int quantum){
int i, wt[40], tat[40], total_wt = 0, total_tat = 0;
findWaitingTime(n, bt, wt, quantum);
findTurnAroundTime(n, bt, wt, tat);
printf("PN\tBT\tWT\tTAT\n");
for ( i = 0; i < n; i++)
printf("%d\t%d\t%d\t%d\n", i + 1, bt[i], wt[i], tat[i]), total_wt += wt[i], total_tat += tat[i];
printf("Average waiting time = %.2f\n", (float)total_wt / n);
printf("Average turn around time = %.2f\n", (float)total_tat / n);}
void main()
{
int burst_time[] = {10, 5, 8};
int n = sizeof(burst_time) / sizeof(burst_time[0]);
int quantum = 2;
clrscr();
findavgTime(n, burst_time, quantum);
getch();
}


2)Multiprogramming-Memory Management- Implementation of fork(), wait(), exec() and exit()
#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
void childProcess() {
printf("Child process.\n");
delay(1000);
}
void parentProcess() {
printf("Parent process.\n");
childProcess();
}
void executeCommand(const char *command) {
printf("Command: %s\n", command);
system(command);
}
void main() {
clrscr();
printf("Simulating fork(), wait(), exec(), exit() in DOS.\n");
parentProcess();
executeCommand("dir");
printf("Exiting program.\n");
exit(0);
getch();
}


3a)MFT
#include<stdio.h> 
#include<conio.h> 
void main()
{
int ms,bs,nob,ef,n,mp[10],tif=0;
int i,p=0;
clrscr();
printf("Enter the total memory available (in Bytes) -- ");
scanf("%d",&ms);
printf("Enter the block size (in Bytes) -- ");
scanf("%d", &bs);
nob=ms/bs; ef=ms - nob*bs;
printf("\nEnter the number of processes -- ");
scanf("%d",&n);
for(i=0;i<n;i++)
{
printf("Enter memory required for process %d (in Bytes)-- ",i+1);
scanf("%d",&mp[i]);
}
printf("\nNo. of Blocks available in memory -- %d",nob);
printf("\n\nPROCESS\tMEMORY REQUIRED\t ALLOCATED\tINTERNAL FRAGMENTATION");
for(i=0;i<n && p<nob;i++)
{
printf("\n %d\t\t%d",i+1,mp[i]);
if(mp[i] > bs)
printf("\t\tNO\t\t---");
else
{
printf("\t\tYES\t%d",bs-mp[i]);
tif = tif + bs-mp[i];
p++;
}
}
if(i<n)
printf("\nMemory is Full, Remaining Processes cannot be accomodated");
printf("\n\nTotal Internal Fragmentation is %d",tif);
printf("\nTotal External Fragmentation is %d",ef);
getch();
}


3b)MVT
#include<stdio.h> 
#include<conio.h> 
void main()
{
int ms,mp[10],i, temp,n=0; char ch = 'y';
clrscr();
printf("\nEnter the total memory available (in Bytes)-- ");
scanf("%d",&ms);
temp=ms; for(i=0;ch=='y';i++,n++)
{
printf("\nEnter memory required for process %d (in Bytes) -- ",i+1);
scanf("%d",&mp[i]);
if(mp[i]<=temp)
{
printf("\nMemory is allocated for Process %d ",i+1);
temp = temp - mp[i];
}
else
{
printf("\nMemory is Full"); break;
}
printf("\nDo you want to continue(y/n) -- ");
scanf(" %c", &ch);
}
printf("\n\nTotal Memory Available -- %d", ms);
printf("\n\n\tPROCESS\t\t MEMORY ALLOCATED ");
for(i=0;i<n;i++)
printf("\n \t%d\t\t%d",i+1,mp[i]);
printf("\n\nTotal Memory Allocated is %d",ms-temp);
printf("\nTotal External Fragmentation is %d",temp);
getch();
}

4)implement first fit, best fit and worst fit algorithm for memory management. 
#include <stdio.h>
#define BLOCKS 5
#define PROCESSES 3
void allocateMemory(int blocks[], int m, int processes[], int n, int choice) {
    int i, j, idx;
    for (i = 0; i < n; i++) {
        idx = -1;
        for (j = 0; j < m; j++) {
            if (blocks[j] >= processes[i] && (choice == 1 || (choice == 2 && (idx == -1 || blocks[j] < blocks[idx])) || (choice == 3 && (idx == -1 || blocks[j] > blocks[idx])))) {
                idx = j;
            }
	}
	if (idx != -1) {
	    printf("P%d allocated to B%d\n", i + 1, idx + 1);
	    blocks[idx] -= processes[i];
	} else {
	    printf("P%d cannot be allocated\n", i + 1);
	}
    }
}
void main() {
    int blocks[BLOCKS], processes[PROCESSES], i, blocks1[BLOCKS], blocks2[BLOCKS], blocks3[BLOCKS];
    clrscr();
    printf("Enter the sizes of %d blocks:\n", BLOCKS);
    for (i = 0; i < BLOCKS; i++) {
	printf("Block %d: ", i + 1);
	scanf("%d", &blocks[i]);
    }
    printf("Enter the sizes of %d processes:\n", PROCESSES);
    for (i = 0; i < PROCESSES; i++) {
	printf("Process %d: ", i + 1);
	scanf("%d", &processes[i]);
    }
    for (i = 0; i < BLOCKS; i++) {
	blocks1[i] = blocks[i];
	blocks2[i] = blocks[i];
	blocks3[i] = blocks[i];
    }
    printf("\nFirst Fit:\n");
    allocateMemory(blocks1, BLOCKS, processes, PROCESSES, 1);
    printf("\nBest Fit:\n");
    allocateMemory(blocks2, BLOCKS, processes, PROCESSES, 2);
    printf("\nWorst Fit:\n");
    allocateMemory(blocks3, BLOCKS, processes, PROCESSES, 3);
    getch();
}


5)Dead Lock Avoidance
#include<stdio.h>
#include<conio.h>
#include<string.h>
void main()
{
int alloc[10][10],max[10][10],avail[10],work[10],total[10],need[10][10];
int i,j,k,n,m,count=0,c=0;
char finish[10];
clrscr();
printf("Enter no. of processes and resources:\n");
scanf("%d%d",&n,&m);
for(i=0;i<=n;i++)
finish[i]='N';
printf("Enter claim matrix:\n");
for(i=0;i<n;i++)
for(j=0;j<m;j++)
scanf("%d",&max[i][j]);
printf("Enter allocation matrix:\n");
for(i=0;i<n;i++)
for(j=0;j<m;j++)
scanf("%d",&alloc[i][j]);
printf("Resource vector:\n");
for(i=0;i<m;i++)
scanf("%d",&total[i]);
for(i=0;i<m;i++)
avail[i]=0;
for(i=0;i<n;i++)
for(j=0;j<m;j++)
avail[j]+=alloc[i][j];
for(i=0;i<m;i++)
work[i]=avail[i];
for(j=0;j<m;j++)
work[j]=total[j]-work[j];
for(i=0;i<n;i++)
for(j=0;j<m;j++)
need[i][j]=max[i][j]-alloc[i][j];
A:for(i=0;i<n;i++)
{
c=0;
for(j=0;j<m;j++)
if((need[i][j]<=work[j])&&(finish[i]=='N'))
c++;
if(c==m)
{
printf("\nAll the resources can be allocated to Process %d",i+1);
printf("\nAvailable resources are:");
for(k=0;k<m;k++)
{
work[k]+=alloc[i][k];
printf("%4d",work[k]);
}
printf("\n");
finish[i]='Y';
printf("Process %d executed? : %c\n",i+1,finish[i]);
count++;
}
}
if(count!=n) goto A;
else
printf("\nSystem is in safe mode");
printf("\nGiven state is in safe state");
getch();
}

6)Dead Lock Prevention
#include<stdio.h>
#include<conio.h>
void main()
{
char job[10][10];
int time[10],tem[10],temp[10],safe[10];
int ind=1,avail,i,j,q,n,t;
clrscr();
printf("Enter no. of jobs: ");
scanf("%d",&n);
for(i=0;i<n;i++)
{
printf("Enter name and time: ");
scanf("%s%d",&job[i],&time[i]);
}
printf("Enter available resources: ");
scanf("%d",&avail);
for(i=0;i<n;i++)
{
temp[i]=time[i];
tem[i]=i;
}
for(i=0;i<n;i++)
for(j=i+1;j<n;j++)
{
if(temp[i]>temp[j])
{
t=temp[i];temp[i]=temp[j];temp[j]=t;
t=tem[i];tem[i]=tem[j];tem[j]=t;
}
}
for(i=0;i<n;i++)
{
q=tem[i];
if(time[q]<=avail)
{
safe[ind]=tem[i];
avail=avail-tem[q];
//printf("%s",job[safe[ind]]);
ind++;
}
else
{
printf("No safe sequence\n");
}
}
printf("Safe sequence is:\n");
for(i=1;i<ind;i++)
printf("%s %d\n",job[safe[i]],time[safe[i]]);
getch();
}


7a)FIFO
#include <stdio.h>
#include <stdlib.h>
#define MAX_FRAMES 3
void fifoPageReplacement(int pages[], int n, int capacity) {
int frames[MAX_FRAMES];
int pageFaults = 0;
int i, j, front = 0;
for ( i = 0; i < capacity; i++) { frames[i] = -1; }
for ( i = 0; i < n; i++) {
int currentPage = pages[i];
int pageFound = 0;
for ( j = 0; j < capacity; j++) {
if (frames[j] == currentPage) { pageFound = 1; break; }}
if (!pageFound) {
frames[front] = currentPage;
front = (front + 1) % capacity;
pageFaults++; }
printf("Page %d loaded into memory.\n", currentPage);
}
printf("\nTotal page faults: %d\n", pageFaults);
}
void main() {
int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 0};
int n = sizeof(pages) / sizeof(pages[0]);
int capacity = 3;
clrscr();
fifoPageReplacement(pages, n, capacity);
getch();
}


7b)LRU
#include <stdio.h>
#define MAX_FRAMES 10
void simulateLRU(int pages[], int numPages, int numFrames) {
int frames[MAX_FRAMES] = {-1};
int pageFaults = 0, i, j, found, lruIndex;
for (i = 0; i < numPages; i++) {
found = 0;
for (j = 0; j < numFrames && !found; j++) { if (frames[j] == pages[i]) found = 1; }
if (!found) { pageFaults++;
for (j = 0; j < numFrames && frames[j] != -1; j++);
if (j < numFrames) frames[j] = pages[i];
else {
lruIndex = 0;
for (j = 1; j < numFrames; j++) {
if (frames[j] != pages[i]) lruIndex = j; }
frames[lruIndex] = pages[i]; }}
printf("Frames: ");
for (j = 0; j < numFrames; j++) {
if (frames[j] != -1) printf("%d ", frames[j]);
} printf("\n" ); }
printf("Page faults: %d\n", pageFaults);
}
void main() {
int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
int numPages = sizeof(pages) / sizeof(pages[0]);
clrscr();
simulateLRU(pages, numPages, 3);
getch();
}

7c)LFU
#include <stdio.h>
#include <conio.h>
typedef struct { int page, freq, lastUsed; } Page;
int findLFU(Page f[], int n) { int i, idx = 0;
for (i = 1; i < n; i++) {
if (f[i].freq < f[idx].freq || (f[i].freq == f[idx].freq && f[i].lastUsed < f[idx].lastUsed)) {
idx = i; }} return idx; }
int lfu(int pages[], int n, int size) { Page f[26], temp;
int i, j, count = 0, faults = 0;
for (i = 0; i < n; i++) { int p = pages[i], found = 0;
for (j = 0; j < count; j++) {
if (f[j].page == p) { f[j].freq++; f[j].lastUsed = i;
found = 1; break; }}
if (!found) { faults++;
if (count < size) {
temp.page = p;
temp.freq = 1;
temp.lastUsed = i;
f[count++] = temp; } else { int idx = findLFU(f, size);
temp.page = p;
temp.freq = 1;
temp.lastUsed = i;
f[idx] = temp;
}}} return faults; }
void main() {
int pages[] = {1, 2, 3, 2, 1, 4, 2, 3};
clrscr();
printf("Page Faults: %d\n", lfu(pages, sizeof(pages) / sizeof(pages[0]), 3));
getch();
}

#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
void childProcess() {
printf("Child process.\n");
delay(1000);
}
void parentProcess() {
printf("Parent process.\n");
childProcess();
}
void executeCommand(const char *command) {
printf("Command: %s\n", command);
system(command);
}
void main() {
clrscr();
printf("Simulating fork(), wait(), exec(), exit() in DOS.\n");
parentProcess();
executeCommand("dir");
printf("Exiting program.\n");
exit(0);
getch();
}


Linux:

1.PRIME OR NOT

#!/bin/bash
read  -p "Enter a number: " n
if [ "$n" -le 1 ]; then
    echo "$n is not a prime number."
    exit
fi
if [ "$n" -eq 2 ]; then
    echo "2 is a prime number."
    exit
fi
if [ $((n % 2)) -eq 0 ]; then
    echo "$n is not a prime number."
    exit
fi
i=3
while [ $((i * i)) -le "$n" ]; do
    if [ $((n % i)) â€“eq 0 ]; then
        echo "$n is not a prime number."
        exit
    fi
    i=$((i + 2))
done
echo "$n is a prime number."

 OUTPUT:
-bash-4.1$ bash raj.sh
Enter a number: 26
26 is not a prime number.

2.FIBONACCI SERIES

#!/bin/bash
echo "enter the range:"
read range
a=0
b=1
echo "Fibonacci series upto $range: "
echo -n "$a "
while [ $b -le $range ]
do
   echo -n "$b "
   temp=$b
   b=$((a+b))
   a=$temp
done
echo

OUTPUT:
-bash-4.1$ bash 42.sh
enter the range:
6
Fibonacci series upto 6:
0 1 1 2 3 5

3.ARMSTONG NUMBER OR NOT

#!/bin/bash
echo -n "Enter a number: "
read num
n=$num
sum=0
while [ $n -gt 0 ]
do
    digit=$(( n % 10 ))
    sum=$(( sum + digit*digit*digit ))
    n=$(( n / 10 ))
done
if [ $sum -eq $num ]; then
    echo "$num is an Armstrong number"
else
    echo "$num is not an Armstrong number"
fi

OUTPUT:
-bash-4.1$ bash shyam.sh
Enter a number: 32
32 is not an Armstrong number


4..MARKS

#!/bin/bash
echo "Enter Student Number:"
read sno
echo "Enter Student Name:"
read sname
echo "Enter marks in 5 subjects (separated by space):"
read m1 m2 m3 m4 m5
# Calculate total
total=$((m1 + m2 + m3 + m4 + m5))
# Calculate percentage (out of 500)
percentage=$((total * 100 / 500))
echo "-----------------------------"
echo "Student Number : $sno"
echo "Student Name   : $sname"
echo "Marks in 5 Subjects: $m1 $m2 $m3 $m4 $m5"
echo "Total Marks    : $total"
echo "Percentage     : $percentage%"
echo "-----------------------------"

OUTPUT:
-bash-4.1$ bash  marks.sh
Enter Student Number:
101
Enter Student Name:
JOHN
Enter marks in 5 subjects (separated by space):
65 78 86 96 85
-----------------------------
Student Number : 101
Student Name   : JOHN
Marks in 5 Subjects: 65 78 86 96 85
Total Marks    : 410
Percentage     : 82%
-----------------------------

5.GRADE
#!/bin/bash

echo "Enter marks of 5 subjects:"
read s1 s2 s3 s4 s5

# Calculate total
total=$((s1 + s2 + s3 + s4 + s5))

# Calculate average
avg=$((total / 5))

echo "Total = $total"
echo "Average = $avg"

# Determine Grade
if [ $avg -ge 80 ]; then
    grade="A"
elif [ $avg -ge 70 ]; then
    grade="B"
elif [ $avg -ge 60 ]; then
    grade="C"
elif [ $avg -ge 50 ]; then
    grade="D"
elif [ $avg -ge 40 ]; then
    grade="E"
else
    grade="Fail"
fi

echo "Grade = $grade"

OUTPUT:
Enter marks of 5 subjects:
85 96 75 98 68
Total = 422
Average = 84
Grade = A

6.MIN AND MAX NUMBER

#!/bin/bash
echo "Enter numbers separated by space:"
read -a arr     # read input into an array
# Initialize min and max with the first element
min=${arr[0]}
max=${arr[0]}
# Loop through all elements
for num in "${arr[@]}"
do
    if [ $num -lt $min ]; then
        min=$num
    fi
    if [ $num -gt $max ]; then
        max=$num
    fi
done
echo "Minimum value: $min"
echo "Maximum value: $max"

OUTPUT:
-bash-4.1$ bash shyamu.sh
Enter numbers separated by space:
20  52
Minimum value: 20
Maximum value: 52


7.PALINDROME

#!/bin/bash
echo "Enter a string:"
read str
# Reverse the string
rev_str=$(echo "$str" | rev)
# Compare original with reversed
if [ "$str" = "$rev_str" ]; then
    echo "\"$str\" is a palindrome"
else
    echo "\"$str\" is NOT a palindrome"
fi

OUTPUT:
Enter a string:
system
"system" is NOT a palindrome

8.AWK PROGRAM 

-bash-4.1$ vi stum2.txt
lavanya 30 100 200 250 300 400
satya 25 300 390 450 670 340
 lasya 35 400 700 500 320 210

-bash-4.1$ vi stum2.awk

{
    name = $1
    roll = $2
    sum = 0
    for(i=3; i<=7; i++) {
        sum += $i
    }
    avg = sum / 5
    printf "Name: %s, Roll No: %s, Total Marks = %d, Average = %.2f\n", name, roll, sum, avg
}

OUTPUT:

-bash-4.1$ awk -f stum2.awk stum2.txt
Name: , Roll No: , Total Marks = 0, Average = 0.00
Name: lavanya, Roll No: 30, Total Marks = 1250, Average = 250.00
Name: satya, Roll No: 25, Total Marks = 2150, Average = 430.00
Name: lasya, Roll No: 35, Total Marks = 2130, Average = 426.00
Name: , Roll No: , Total Marks = 0, Average = 0.00

9.COUNT

#!/bin/bash
echo "Enter filename:"
read file

n=1
while read line
do
    words=$(echo "$line" | wc -w)
    chars=$(echo "$line" | wc -c)
    echo "Line $n: Words = $words, Characters = $chars"
    n=$((n+1))
done < "$file"

OUTPUT:

1)hello.c
Line 1: Words = 1, Characters = 18
Line 2: Words = 0, Characters = 1
Line 3: Words = 2, Characters = 11
Line 4: Words = 1, Characters = 2
Line 5: Words = 2, Characters = 23
Line 6: Words = 2, Characters = 10
Line 7: Words = 1, Characters = 2
Line 8: Words = 0, Characters = 1

2)pal.sh
Line 1: Words = 1, Characters = 12
Line 2: Words = 3, Characters = 20

UNIX

1) Emulate ls -l
SOURCE CODE:
#include <stdio.h>
#include <dir.h>
void main() {
    struct ffblk f;
    int d, yr, mo, dy;
    d = findfirst("*.*", &f, FA_DIREC | FA_ARCH | FA_RDONLY | FA_HIDDEN);
    while (!d) {
        yr = (f.ff_fdate >> 9) + 1980;
        mo = (f.ff_fdate >> 5) & 15;
        dy = f.ff_fdate & 31;
        printf("%c%c%c\t%8ld\t%02d-%02d-%d\t%s\n",
            (f.ff_attrib & FA_DIREC) ? 'd' : '-',
            (f.ff_attrib & FA_RDONLY) ? 'r' : 'w',
            (f.ff_attrib & FA_HIDDEN) ? 'h' : '-',
            f.ff_fsize, dy, mo, yr, f.ff_name);
        d = findnext(&f);
    }
}

OUTPUT:
dw-           0	15-10-2024	INCLUDE
-w-         512	22-12-2025	NONAME00.C
-w-       12050	01-11-2023	PROJECT.EXE
-r-        2048	05-01-2022	README.TXT
dw-           0	10-09-2024	BIN
-wh         128	12-08-2024	SECRET.LOG

2) 2 commands concurrently with a command pipe
SOURCE CODE:
#include<stdio.h>
#include<stdlib.h>
void main()
{
clrscr();
system("dir | sort");
//system("ls -l | sort");
getch();
}

OUTPUT:
2 Dir(s)  20,450,050,123 bytes free
               3 File(s)         15,400 bytes
 Directory of C:\TURBOC3\SOURCE
 Volume Serial Number is A1B2-C3D4
 Volume in drive C has no label.
10-05-2025  09:30 AM               512 INPUT.C
11-15-2025  02:15 PM            12,050 OUTPUT.EXE
12-22-2025  11:11 AM    <DIR>          .
12-22-2025  11:11 AM    <DIR>          ..
12-22-2025  11:12 AM             2,838 SORT.C
