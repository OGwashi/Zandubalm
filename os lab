	1.FCFS

#include<stdio.h>
#include<conio.h>
int main()
{
 int n,i;
 int p[20],at[20],bt[20],ct[20],tat[20],wt[20];
 float avg_tat=0,avg_wt=0;
 clrscr();
 printf("Enter number of processes : ");
 scanf("%d",&n);
 printf("\n Enter Arrival time :");
 for(i=0;i<n;i++)
 {
  scanf("%d",&at[i]);
  p[i]=i+1;
 }
printf("\n Enter Burst time : ");
for(i=0;i<n;i++)
 {
  scanf("%d",&bt[i]);
 }
ct[0]=at[0]+bt[0];
for(i=1;i<n;i++)
 {
  if(ct[i-1]<at[i])
   {
    ct[i]=at[i]+bt[i];
   }
  else
  {
   ct[i]=ct[i-1]+bt[i];
  }
 }
for(i=0;i<n;i++)
{
 tat[i]=ct[i]-at[i];
 wt[i]=tat[i]-bt[i];
 avg_tat+=tat[i];
 avg_wt+=wt[i];
}
avg_tat/=n;
avg_wt/=n;
printf("\n Process\t at\t bt\t ct\t tat\t wt");
for(i=0;i<n;i++)
{
 printf("\n p%d\t %d\t %d\t %d\t %d\t %d",i+1,at[i],bt[i],ct[i],tat[i],wt[i]);
}
printf("\n Average TurnAround Time : %2f",avg_tat);
printf("\n Average Waiting Time : %2f",avg_wt);
getch();
return 0;

}

_____________________________________________________________

	2.sjf ( p )
 
#include <stdio.h>
#include <limits.h>

int main() {
    int n, bt[20], rt[20], wt[20]={0}, tat[20], ct[20], i, t=0, complete=0, minm, shortest;
    float awt=0, atat=0;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    printf("Enter Burst Times:\n");
    for(i=0;i<n;i++) {
        printf("P%d: ", i+1);
        scanf("%d", &bt[i]);
        rt[i]=bt[i];
    }

    while(complete!=n) {
        shortest=-1; minm=INT_MAX;
        for(i=0;i<n;i++)
            if(rt[i]>0 && rt[i]<minm) {
                minm=rt[i]; shortest=i;
            }

        if(shortest==-1) { t++; continue; }

        rt[shortest]--;

        if(rt[shortest]==0) {
            complete++;
            ct[shortest]=t+1; // Completion Time
            tat[shortest]=ct[shortest]; // TAT = CT (since AT=0)
            wt[shortest]=tat[shortest]-bt[shortest];
        }
        t++;
    }

    for(i=0;i<n;i++) {
        awt+=wt[i];
        atat+=tat[i];
    }

    printf("\nProcess\tBT\tCT\tWT\tTAT");
    for(i=0;i<n;i++)
        printf("\nP%d\t%d\t%d\t%d\t%d", i+1, bt[i], ct[i], wt[i], tat[i]);

    printf("\nAverage WT=%.2f, Average TAT=%.2f\n", awt/n, atat/n);
    return 0;
}

 ______________________________________________________________________________

	2.1 SJF ( non preemtive)

#include <stdio.h>

int main() {
    int n, bt[20], wt[20], tat[20], ct[20], i, j;
    float awt = 0, atat = 0;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    printf("Enter Burst Times:\n");
    for(i=0;i<n;i++) {
        printf("P%d: ", i+1);
        scanf("%d", &bt[i]);
    }

    // Sort processes by burst time (simple bubble sort)
    for(i=0;i<n-1;i++)
        for(j=i+1;j<n;j++)
            if(bt[i] > bt[j]) {
                int temp = bt[i]; bt[i]=bt[j]; bt[j]=temp;
            }

    ct[0] = bt[0];
    for(i=1;i<n;i++) ct[i] = ct[i-1] + bt[i];

    for(i=0;i<n;i++) {
        tat[i] = ct[i]; // TAT = CT (since AT=0)
        wt[i] = tat[i] - bt[i]; // WT = TAT - BT
        awt += wt[i];
        atat += tat[i];
    }

    printf("\nProcess\tBT\tCT\tWT\tTAT");
    for(i=0;i<n;i++)
        printf("\nP%d\t%d\t%d\t%d\t%d", i+1, bt[i], ct[i], wt[i], tat[i]);

    printf("\nAverage WT=%.2f, Average TAT=%.2f\n", awt/n, atat/n);
    return 0;
}

---------------------------------------------------------------------------------
		3.priority ( n-p )

#include<stdio.h>
#include<conio.h>
int main()
{
 int n,i,j,temp;
 int p[20],at[20],bt[20],pr[20],ct[20],tat[20],wt[20];
 float avg_tat=0,avg_wt=0;
 clrscr();
 printf("\n Enter the no.of processes : ");
 scanf("%d",&n);
 printf("\n Enter Annual time ,Burst time,Priority for each process..!  ");
for(i=0;i<n;i++)
 {
  printf("\n Process %d: ",i+1);
  scanf("%d %d %d",&at[i],&bt[i],&pr[i]);
  p[i]=i+1;
 }
for(i=0;i<n-1;i++)
 {
 for(j=i+1;j<n;j++)
  {
  if(pr[i] > pr[j] || (pr[i] == pr[j] && at[i] > at[j]))
   {
    temp=pr[i];
    pr[i]=pr[j];
    pr[j]=temp;

    temp=at[i];
    at[i]=at[j];
    at[j]=temp;

    temp=bt[i];
    bt[i]=bt[j];
    bt[j]=temp;

    temp=p[i];
    p[i]=p[j];
    p[j]=temp;
   }
  }
 }
ct[0]=at[0]+bt[0];
tat[0]=ct[0]-at[0];
wt[0]=tat[0]-bt[0];

for(i=1;i<n;i++)
 {
 if(at[i] > ct[i-1])
  {
   ct[i]=at[i]+bt[i];
  }
 else
  {
   ct[i]=ct[i+1]+bt[i];
   tat[i]=ct[i]-at[i];
   wt[i]=tat[i]-bt[i];
  }
 }
printf("\n Processes\t at\t bt\t pr\t ct\t tat\t wt\n");
for(i=0;i<n;i++)
 {
  printf("\n p%d\t %d\t %d\t %d\t %d\t %d\t %d\n",p[i],at[i],bt[i],pr[i],ct[i],tat[i],wt[i]);
  avg_tat+=tat[i];
  avg_wt+=wt[i];
  avg_tat/=n;
  avg_wt/=n;
 }
printf("\n Average TAT =%2f",avg_tat);
printf("\n Average WT =%2f",avg_wt);
getch();
return 0;

}
________________________________________________________________________________________________
	
		PRIORITY (P)
#include <stdio.h>

int main() {
    int n, i, smallest;
    int pid[20], bt[20], pr[20], rt[20]; 
    int wt[20], tat[20], completion[20];
    int time = 0, completed = 0;
    float avgWT = 0, avgTAT = 0;

    printf("---- PREEMPTIVE PRIORITY SCHEDULING ----\n");
    printf("Enter number of processes: ");
    scanf("%d", &n);

    for (i = 0; i < n; i++) {
        pid[i] = i;
        printf("Enter Burst Time of P%d: ", i);
        scanf("%d", &bt[i]);
        printf("Enter Priority of P%d: ", i);
        scanf("%d", &pr[i]);
        rt[i] = bt[i];  // remaining time
    }

    // CPU Simulation (Preemptive Priority)
    while (completed != n) {
        smallest = -1;

        // find process with highest priority
        for (i = 0; i < n; i++) {
            if (rt[i] > 0) {
                if (smallest == -1 || pr[i] < pr[smallest]) {
                    smallest = i;
                }
            }
        }

        rt[smallest]--;
        time++;

        if (rt[smallest] == 0) {
            completion[smallest] = time;
            completed++;
        }
    }

    // Calculate WT and TAT
    for (i = 0; i < n; i++) {
        tat[i] = completion[i];
        wt[i] = tat[i] - bt[i];

        avgWT += wt[i];
        avgTAT += tat[i];
    }

    avgWT /= n;
    avgTAT /= n;

    // Display results
    printf("\nPID\tPriority\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t%d\t\t%d\t\t%d\t\t%d\n",
               pid[i], pr[i], bt[i], wt[i], tat[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avgWT);
    printf("\nAverage Turnaround Time: %.2f\n", avgTAT);

    return 0;
}

_______________________________________________________________________________________________
		
			Round Robin

#include<stdio.h>
#include<conio.h>
void main()
{
int ts,pid[10],need[10],wt[10],tat[10],i,j,n,n1;
int bt[10],flag[10],ttat=0,twt=0;
float awt,atat;
clrscr();
printf("\t\t ROUND ROBIN SCHEDULING \n");
printf("Enter the number of Processors \n");
scanf("%d",&n);
n1=n;
printf("\n Enter the Timeslice \n");
scanf("%d",&ts);
for(i=1;i<=n;i++)
{
 printf("\n Enter the process ID %d",i);
 scanf("%d",&pid[i]);
 printf("\n Enter the Burst Time for the process");
 scanf("%d",&bt[i]);
 need[i]=bt[i];
}
for(i=1;i<=n;i++)
{
 flag[i]=1;
 wt[i]=0;
}
while(n!=0)
{
 for(i=1;i<=n;i++)
 {
 if(need[i]>=ts)
 {
 for(j=1;j<=n;j++)
 {
 if((i!=j)&&(flag[i]==1)&&(need[j]!=0))
 wt[j]+=ts;
 }
 need[i]-=ts;
 if(need[i]==0)
 {
flag[i]=0;
n--;
 }
 }
 else
 {
 for(j=1;j<=n;j++)
 {
 if((i!=j)&&(flag[i]==1)&&(need[j]!=0))
 wt[j]+=need[i];
 }
 need[i]=0;
 n--;
 flag[i]=0;
 }
}
}
for(i=1;i<=n1;i++)
{
 tat[i]=wt[i]+bt[i];
 twt=twt+wt[i];
 ttat=ttat+tat[i];
}
awt=(float)twt/n1;
atat=(float)ttat/n1;
printf("\n\n ROUND ROBIN SCHEDULING ALGORITHM \n\n");
printf("\n\n Process \t Process ID \t BurstTime \t Waiting Time \t TurnaroundTime \n ");
for(i=1;i<=n1;i++)
{
 printf("\n %5d \t %5d \t\t %5d \t\t %5d \t\t %5d \n", i,pid[i],bt[i],wt[i],tat[i]);
}
printf("\n The average Waiting Time=4.2f",awt);
printf("\n The average Turn around Time=4.2f",atat);
getch();
}

________________________________________________________________________________________________

		MFT 

#include <stdio.h>
#include <conio.h>

void main()
{
    int ms, i, ps[20], n, size, p[20], s, intr = 0;

    clrscr();

    printf("Enter size of memory: ");
    scanf("%d", &ms);

    printf("Enter memory for OS: ");
    scanf("%d", &s);

    ms = ms - s;   // usable memory after OS

    printf("Enter no. of partitions to be divided: ");
    scanf("%d", &n);

    size = ms / n;  // size of each partition

    for (i = 0; i < n; i++)
    {
        printf("\nEnter process id and process size: ");
        scanf("%d%d", &p[i], &ps[i]);

        if (ps[i] <= size)
        {
            intr = intr + (size - ps[i]);   // internal fragmentation
            printf("Process %d is allocated\n", p[i]);
        }
        else
        {
            printf("Process %d is blocked\n", p[i]);
        }
    }

    printf("\nTotal internal fragmentation is %d", intr);

    getch();
}

______________________________________________________________________________

       MVT

#include <stdio.h>
#include <conio.h>

void main()
{
    int i, m, n, tot, s[30];

    clrscr();

    printf("Enter total memory size: ");
    scanf("%d", &tot);

    printf("Enter no. of pages: ");
    scanf("%d", &n);

    printf("Enter memory for OS: ");
    scanf("%d", &m);

    // Enter size of each page
    for (i = 0; i < n; i++) {
        printf("Enter size of page %d: ", i + 1);
        scanf("%d", &s[i]);
    }

    // Available memory after OS
    tot = tot - m;

    // Allocation of pages
    for (i = 0; i < n; i++) {
        if (tot >= s[i]) {
            printf("Allocate page %d\n", i + 1);
            tot = tot - s[i];    // reduce remaining memory
        } else {
            printf("Page %d is blocked\n", i + 1);
        }
    }

    
    printf("External fragmentation is = %d\n", tot);

    getch();
}
____________________________________________________________________________
		First fit:

#include <stdio.h>
#include<conio.h>
int main() {
int blocks[10], processes[10], n, p, i, j, found, frag, total_frag = 0;
clrscr();
printf("Enter number of memory blocks (max 10): ");
scanf("%d", &n);
if (n <= 0 || n > 10) {
printf("Invalid input. Use 1 to 10 blocks.\n");
return 1;
}
for (i = 0; i < n; i++) {
printf("Block %d size: ", i + 1);
scanf("%d", &blocks[i]);
if (blocks[i] <= 0) {
printf("Invalid size. Use positive value.\n");
return 1;
}
}
printf("Enter number of processes (max 10): ");
scanf("%d", &p);
if (p <= 0 || p > 10) {
printf("Invalid input. Use 1 to 10 processes.\n");
return 1;
}
for (i = 0; i < p; i++) {
printf("Process %d size: ", i + 1);
scanf("%d", &processes[i]);
if (processes[i] <= 0) {
printf("Invalid size. Use positive value.\n");
return 1;
}
}
printf("\n%-10s%-10s%-15s%-15s\n", "Process", "Size", "Allocated", "Fragmentation");
for (i = 0; i < p; i++) {
found = 0;
for (j = 0; j < n; j++) {
if (processes[i] <= blocks[j] && blocks[j] != -1) {
frag = blocks[j] - processes[i];
total_frag += frag;
printf("%-10d%-10d%-15s%-15d\n", i + 1, processes[i], "Yes", frag);
blocks[j] = -1;
found = 1;
break;
}
}
if (!found) {
printf("%-10d%-10d%-15s%-15d\n", i + 1, processes[i], "No", 0);
}
}
printf("\nTotal Internal Fragmentation: %d\n", total_frag);
getch();
return 0;
}

_________________________________________________________________________________

		BEST FIT

#include <stdio.h>
#include <conio.h>
int main() {
int bl[10], pr[10], n, p, i, j, found, total_frag=0, best_idx, min_size, frag;
clrscr();
printf("Enter number of memory blocks (max 10): ");
scanf("%d", &n);
if (n <= 0 || n > 10) {
printf("Invalid input. Use 1 to 10 blocks.\n");
return 1;
}
for (i = 0; i < n; i++) {
printf("Block %d size: ", i + 1);
scanf("%d", &bl[i]);
if (bl[i] <= 0) {
printf("Invalid size. Use positive value.\n");
return 1;
}
}
printf("Enter number of processes (max 10): ");
scanf("%d", &p);
if (p <= 0 || p > 10) {
printf("Invalid input. Use 1 to 10 processes.\n");
return 1;
}
for (i = 0; i < p; i++) {
printf("Process %d size: ", i + 1);
scanf("%d", &pr[i]);
if (pr[i] <= 0) {
printf("Invalid size. Use positive value.\n");
return 1;
}
}
printf("\n%-10s%-10s%-15s%-15s\n", "Process", "Size", "Allocated", "Fragmentation");
for (i = 0; i < p; i++) {
found = 0;
best_idx = -1;
min_size = 999999;
for (j = 0; j < n; j++) {
if (pr[i] <= bl[j] && bl[j] != -1 && bl[j] < min_size) {
min_size = bl[j];
best_idx = j;
found = 1;
}
}
if (found) {
frag = bl[best_idx] - pr[i];
total_frag += frag;
printf("%-10d%-10d%-15s%-15d\n", i + 1, pr[i], "Yes", frag);
bl[best_idx] = -1;
} else {
printf("%-10d%-10d%-15s%-15d\n", i + 1, pr[i], "No", 0);
}
}
printf("\nTotal Internal Fragmentation: %d\n", total_frag);
getch();
return 0;
}

__________________________________________________________________________________

		Worst fit

#include <stdio.h>
#include <conio.h>
int main() {
int bl[10], pr[10], n, p, i, j, found, total_frag=0, worst_idx, max_size, frag;
clrscr();
printf("Enter number of memory blocks (max 10): ");
scanf("%d", &n);
if (n <= 0 || n > 10) {
printf("Invalid input. Use 1 to 10 blocks.\n");
return 1;
}
for (i = 0; i < n; i++) {
printf("Block %d size: ", i + 1);
scanf("%d", &bl[i]);
if (bl[i] <= 0) {
printf("Invalid size. Use positive value.\n");
return 1;
}
}
printf("Enter number of processes (max 10): ");
scanf("%d", &p);
if (p <= 0 || p > 10) {
printf("Invalid input. Use 1 to 10 processes.\n");
return 1;
}
for (i = 0; i < p; i++) {
printf("Process %d size: ", i + 1);
scanf("%d", &pr[i]);
if (pr[i] <= 0) {
printf("Invalid size. Use positive value.\n");
return 1;
}
}
printf("\n%-10s%-10s%-15s%-15s\n", "Process", "Size", "Allocated", "Fragmentation");
for (i = 0; i < p; i++) {
found = 0;
worst_idx = -1;
max_size = -1;
for (j = 0; j < n; j++) {
if (pr[i] <= bl[j] && bl[j] != -1 && bl[j] > max_size) {
max_size = bl[j];
worst_idx = j;
found = 1;
}
}
if (found) {
frag = bl[worst_idx] - pr[i];
total_frag += frag;
printf("%-10d%-10d%-15s%-15d\n", i + 1, pr[i], "Yes", frag);
bl[worst_idx] = -1;
} else {
printf("%-10d%-10d%-15s%-15d\n", i + 1, pr[i], "No", 0);
}
}
printf("\nTotal Internal Fragmentation: %d\n", total_frag);
getch();
return 0;
}

__________________________________________________________________________

      Bankers algorithm deadlock avoidance

#include <stdio.h>
#include <conio.h>
#define N 10
int main() {
 int n, m, i, j, k, count = 0;
 int alloc[N][N], max[N][N], need[N][N], avail[N], finish[N] = {0}, safe[N];
 clrscr();
 printf("Processes: "); scanf("%d", &n);
 printf("Resources: "); scanf("%d", &m);
 printf("Allocation Matrix:\n");
 for (i = 0; i < n; i++)
 {
 for (j = 0; j < m; j++){
 scanf("%d", &alloc[i][j]);}
 }
 printf("Max Matrix:\n");
 for (i = 0; i < n; i++) {
 for (j = 0; j < m; j++) {
 scanf("%d", &max[i][j]);}
 }
 printf("Available Resources:\n");
 for (j = 0; j < m; j++) scanf("%d", &avail[j]);

 for (i = 0; i < n; i++)
 for (j = 0; j < m; j++)
 need[i][j] = max[i][j] - alloc[i][j];

 while (count < n) {
 int found = 0;
 for (i = 0; i < n; i++) {
 if (!finish[i]) {
 for (j = 0; j < m && need[i][j] <= avail[j]; j++);
 if (j == m) {
 for (k = 0; k < m; k++) avail[k] += alloc[i][k];
 safe[count++] = i;
 finish[i] = 1;
 found = 1;
 }
 }
 }
 if (!found) {
 printf("Unsafe State!\n");
 return 1;
 }
 }

 printf("Safe State. Sequence: ");
 for (i = 0; i < n; i++) printf("P%d ", safe[i]);
 printf("\n");
 getch();
 return 0;
}

________________________________________________________________________________

                Bankers algorithm deadlock prevention.

#include <stdio.h>
#include <conio.h>

void main() {
    int n, m; // n = processes, m = resources
    int alloc[10][10], max[10][10], avail[10];
    int need[10][10], request[10];
    int finish[10], safeSeq[10];
    int i, j, k, process, count = 0;

    clrscr();

    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the number of resources: ");
    scanf("%d", &m);

    printf("\nEnter the Allocation Matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    printf("\nEnter the Max Matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            scanf("%d", &max[i][j]);

    printf("\nEnter the Available Resources:\n");
    for (i = 0; i < m; i++)
        scanf("%d", &avail[i]);

    // Calculate Need Matrix
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            need[i][j] = max[i][j] - alloc[i][j];

    printf("\nEnter the process number (0 to %d) making the request: ", n - 1);
    scanf("%d", &process);

    printf("Enter the request for each resource: ");
    for (i = 0; i < m; i++)
        scanf("%d", &request[i]);


    for (i = 0; i < m; i++) {
        if (request[i] > need[process][i]) {
            printf("\nError: Process has exceeded its maximum claim!\n");
            getch();
            return;
        }
    }

    
    for (i = 0; i < m; i++) {
        if (request[i] > avail[i]) {
            printf("\nResources not available. Process must wait.\n");
            getch();
            return;
        }
    }


    for (i = 0; i < m; i++) {
        avail[i] -= request[i];
        alloc[process][i] += request[i];
        need[process][i] -= request[i];
    }

    // Safety Check
    for (i = 0; i < n; i++)
        finish[i] = 0;
    count = 0;

    while (count < n) {
        int found = 0;
        for (i = 0; i < n; i++) {
            if (finish[i] == 0) {
                int flag = 0;
                for (j = 0; j < m; j++) {
                    if (need[i][j] > avail[j]) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0) {
                    for (k = 0; k < m; k++)
                        avail[k] += alloc[i][k];
                    safeSeq[count++] = i;
                    finish[i] = 1;
                    found = 1;
                }
            }
        }
        if (found == 0)
            break;
    }

    if (count == n)
        printf("\nRequest can be granted safely. No Deadlock!\n");
    else
        printf("\nGranting the request may lead to DEADLOCK. Request Denied!\n");

    getch();
}
________________________________________________________________________________________________

		FIFO

#include <stdio.h>

void display(int fr[], int frsize);

int main() {

    int i, j, n, frsize, top = 0, pf = 0;
    int page[30], fr[10];
    int flag1, flag2;

    printf("Enter number of pages: ");
    scanf("%d", &n);

    printf("Enter page reference string: ");
    for (i = 0; i < n; i++)
        scanf("%d", &page[i]);

    printf("Enter number of frames: ");
    scanf("%d", &frsize);

    
    for (i = 0; i < frsize; i++)
        fr[i] = -1;

    for (j = 0; j < n; j++) {

        flag1 = 0;
        flag2 = 0;


        for (i = 0; i < frsize; i++) {
            if (fr[i] == page[j]) {
                flag1 = 1;
                flag2 = 1;
                break;
            }
        }

        
        if (flag1 == 0) {
            pf++;
            for (i = 0; i < frsize; i++) {
                if (fr[i] == -1) {
                    fr[i] = page[j];
                    flag2 = 1;
                    break;
                }
            }
        }

        if (flag2 == 0) {
            fr[top] = page[j];
            top++;
            if (top >= frsize)
                top = 0;
        }

        printf("\nAfter referencing page %d: ", page[j]);
        display(fr, frsize);
    }

    printf("\n\nTotal Page Faults = %d\n", pf);

    return 0;
}

void display(int fr[], int frsize) {

    int i;

    printf("\nFrames: ");
    for (i = 0; i < frsize; i++)
        printf("\t%d", fr[i]);
}
_________________________________________________________________________________________________

		LRU

#include <stdio.h>

int main() {

    int page[50], frame[10];
    int n, f, i, j, k;
    int pagefault = 0;
    int count[10], min, recent;
    int found;
    clrscr();
    printf("Enter no of pages: ");
    scanf("%d", &n);

    printf("Enter the page reference string:\n");
    for (i = 0; i < n; i++)
        scanf("%d", &page[i]);

    printf("Enter no of frames: ");
    scanf("%d", &f);

    for (i = 0; i < f; i++) {
        frame[i] = -1;
        count[i] = 0;
    }

    for (i = 0; i < n; i++) {

        found = 0;

        for (j = 0; j < f; j++) {
            if (frame[j] == page[i]) {
                found = 1;
                count[j] = count[j] + 1;
                break;
            }
        }

        if (!found) {
            min = 0;
            for (j = 1; j < f; j++) {
                if (count[j] < count[min]) {
                    min = j;
                }
            }

            frame[min] = page[i];
            count[min] = count[min] + 1;
            pagefault++;

        }

        printf("For page %d: ", page[i]);
        for (k = 0; k < f; k++) {
            if (frame[k] != -1)
                printf("%d ", frame[k]);
        }
        printf("\n");
    }

    printf("Total page faults = %d\n", pagefault);

    return 0;
}

__________________________________________________________________________________________________

		LFU

#include <stdio.h>

int fr[10], n, m;

void display() {
    int i;
    for (i = 0; i < m; i++)
        printf("%d\t", fr[i]);
    printf("\n");
}

int main() {
    int page[50], i, j, k, l, flag1, flag2, pf = 0, lg[10], index, found, max;
    float pr;
    clrscr();
    printf("Enter the length of the reference string: ");
    scanf("%d", &n);
    printf("Enter the reference string: ");
    for (i = 0; i < n; i++)
        scanf("%d", &page[i]);
    printf("Enter number of frames: ");
    scanf("%d", &m);

    for (i = 0; i < m; i++)
        fr[i] = -1;

    for (j = 0; j < n; j++) {
        flag1 = flag2 = 0;

        for (i = 0; i < m; i++) {
            if (fr[i] == page[j]) { // page hit
                flag1 = flag2 = 1;
                break;
            }
        }

        if (flag1 == 0) { // page fault
            for (i = 0; i < m; i++) {
                if (fr[i] == -1) {
                    fr[i] = page[j];
                    flag2 = 1;
                    pf++;
                    break;
                }
            }
        }

        if (flag2 == 0) { // optimal replacement
            for (i = 0; i < m; i++)
                lg[i] = 0;

            for (i = 0; i < m; i++) {
                for (k = j + 1; k < n; k++) {
                    if (fr[i] == page[k]) {
                        lg[i] = k - j;
                        break;
                    }
                }
            }

            found = 0;
            for (i = 0; i < m; i++) {
                if (lg[i] == 0) {
                    index = i;
                    found = 1;
                    break;
                }
            }

            if (found == 0) {
                max = lg[0];
                index = 0;
                for (i = 1; i < m; i++) {
                    if (lg[i] > max) {
                        max = lg[i];
                        index = i;
                    }
                }
            }

            fr[index] = page[j];
            pf++;
        }

        display();
    }

    printf("Number of page faults: %d\n", pf);
    pr = (float)pf / n * 100;
    printf("Page fault rate = %.2f%%\n", pr);

    return 0;
}

________________________________________________________ ____________________________
       
      LINKED FILE ALLOCATION

#include <stdio.h>
#include <stdlib.h>

#define MAX 50

struct block {
    int data;
    int next;
}disk[MAX];

int freeBlock[MAX];   

void initialize()
{
    for(int i=0;i<MAX;i++)
    {
        disk[i].data = -1;
        disk[i].next = -1;
        freeBlock[i] = 1;
    }
}

int getFreeBlock()
{
    for(int i=0;i<MAX;i++)
    {
        if(freeBlock[i] == 1)
        {
            freeBlock[i] = 0;
            return i;
        }
    }
    return -1; 
}

void allocateFile(int fileSize)
{
    int start = -1, previous = -1, current;

    printf("\nAllocating file of size %d blocks...\n", fileSize);

    for(int i=0;i<fileSize;i++)
    {
        current = getFreeBlock();
        if(current == -1)
        {
            printf("Disk full! Cannot allocate file.\n");
            return;
        }

        disk[current].data = i+1;

        if(start == -1)
            start = current;
        else
            disk[previous].next = current;

        previous = current;
    }

    printf("File allocated successfully!\n");

    printf("\nFile block chain (Linked List):\n");
    current = start;
    while(current != -1)
    {
        printf("[Block %d | next -> %d]\n", current, disk[current].next);
        current = disk[current].next;
    }
}

void displayDisk()
{
    printf("\nDisk Status:\n");
    printf("Block\tUsed?\tNext\n");
    for(int i=0;i<MAX;i++)
    {
        printf("%d\t%s\t%d\n",
               i,
               freeBlock[i]==0 ? "Yes" : "No",
               disk[i].next);
    }
}

int main()
{
    int size;

    initialize();

    printf("===== LINKED LIST FILE ALLOCATION SIMULATION =====\n");

    printf("Enter file size (no. of blocks needed): ");
    scanf("%d",&size);

    allocateFile(size);

    displayDisk();

    return 0;
}
_____________________________________________

       INDEXED FILE ALLOCATION

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>

struct Node {
    int blockNo;
    int data;
    struct Node* next;
};

struct Node* createNode(int blockNo) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->blockNo = blockNo;
    newNode->data = -1;
    newNode->next = NULL;
    return newNode;
}

void insert(struct Node** head, int blockNo) {
    struct Node* newNode = createNode(blockNo);
    struct Node* temp;

    if (*head == NULL) {
        *head = newNode;
    } else {
        temp = *head;
        while (temp->next != NULL)
            temp = temp->next;

        temp->next = newNode;
    }
}

void insertData(struct Node* head, int blockNo, int value) {
    struct Node* temp = head;

    while (temp != NULL) {
        if (temp->blockNo == blockNo) {
            temp->data = value;
            return;
        }
        temp = temp->next;
    }

    printf("\nBlock %d not found.\n", blockNo);
}

int main() {
    int indexBlock, n, blockNo;
    int tBlock, value, i;

    struct Node* head = NULL;
    int* indexArray;

    clrscr();

    printf("Enter Index Block Number: ");
    scanf("%d", &indexBlock);

    printf("Enter number of data blocks to allocate: ");
    scanf("%d", &n);

    indexArray = (int*)malloc(n * sizeof(int));

    printf("\nEnter the block numbers:\n");
    for (i = 0; i < n; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &blockNo);
        insert(&head, blockNo);
        indexArray[i] = blockNo;
    }

    printf("\nEnter block number to insert data into: ");
    scanf("%d", &tBlock);

    printf("Enter data to store: ");
    scanf("%d", &value);

    insertData(head, tBlock, value);

    clrscr();
    printf("Index Block: %d\n", indexBlock);

    printf("\nIndex Block Contains:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", indexArray[i]);
    }

    printf("\n\nBlocks and Their Data:\n");
    while (head != NULL) {
        printf("Block %d -> Data: %d\n", head->blockNo, head->data);
        head = head->next;
    }
    getch();
    return 0;
}

____________________________________________________________________________________

     SEQUENTIAL / CONTIGUOUS FILE ALLOCATION

#include <stdio.h>

int main() {
    int blocks[50] = {0};
    int n, length, i, j, k, flag, start;

    printf("Enter how many files you want to allocate: ");
    scanf("%d", &n);

    for (i = 0; i < n; i++) {
        printf("\nEnter length of file %d: ", i + 1);
        scanf("%d", &length);

        start = -1;

        for (j = 0; j <= 50 - length; j++) {
            flag = 1;

            for (k = j; k < j + length; k++) {
                if (blocks[k] == 1) {
                    flag = 0;
                    break;
                }
            }

            if (flag == 1) {
                start = j;
                break;
            }
        }

        if (start != -1) {
            for (k = start; k < start + length; k++) {
                blocks[k] = 1;
            }
            printf("File %d allocated from block %d to %d.\n",
                   i + 1, start, start + length - 1);
        } else {
            printf("File %d cannot be allocated.\n", i + 1);
        }
    }

    printf("\nFinal block status:\n");
    for (i = 0; i < 50; i++) {
        printf("Block %2d: %d\n", i, blocks[i]);
    }

    return 0;
}
____________________________________________________________________________________

         



		        ALL      THE	     BEST


######## LINUX ########
 

      PRIME
#!/bin/bash
echo "Enter a number:"
read num
if ! [[ "$num" =~ ^[0-9]+$ ]]; then
  echo "Please enter a valid number."
  exit 1
fi
if [ $num -le 1 ]; then
  echo "$num is not a prime number."
  exit 0
fi
is_prime=1
for (( i=2; i<=$((num/2)); i++ ))
do
  if [ $((num % i)) -eq 0 ]; then
    is_prime=0
    break
  fi
done
if [ $is_prime -eq 1 ]; then
  echo "$num is a prime number."
else
  echo "$num is not a prime number."
fi



      FIBONACCI

#!/bin/bash
echo "Enter the range:"
read range
a=0
b=1
echo "Fibonacci series up to $range:"
while [ $a -le $range ]
do
  echo -n "$a "
  fib=$((a + b))
  a=$b
  b=$fib
done
echo

      ARMSTRONG

#!/bin/bash
echo "Enter a number:"
read num
original_num=$num
sum=0
len=${#num}
while [ $num -gt 0 ]
do
  digit=$((num % 10))  
  sum=$((sum + digit**len))  
  num=$((num / 10))  
done
if [ $sum -eq $original_num ]; then
  echo "$original_num is an Armstrong number."
else
  echo "$original_num is not an Armstrong number."
fi




        MARKS

#!/bin/bash
echo "Enter student number:"
read student_number
echo "Enter student name:"
read student_name
echo "Enter marks for 5 subjects:"
echo "Subject 1: "
read marks1
echo "Subject 2: "
read marks2
echo "Subject 3: "
read marks3
echo "Subject 4: "
read marks4
echo "Subject 5: "
read marks5
total=$((marks1 + marks2 + marks3 + marks4 + marks5))
average=$((total / 5))
if [ $average -ge 80 ]; then
    grade="A"
elif [ $average -ge 70 ]; then
    grade="B"
elif [ $average -ge 60 ]; then
    grade="C"
elif [ $average -ge 50 ]; then
    grade="D"
elif [ $average -ge 40 ]; then
    grade="E"
else
    grade="F"
fi
echo "Student Number: $student_number"
echo "Student Name: $student_name"
echo "Total Marks: $total"
echo "Average: $average"
echo "Grade: $grade"

       Maximum and Minimum in Array (Bash Script)

#!/bin/bash

echo "Enter the number of elements:"
read n

echo "Enter $n numbers:"
for ((i=0; i<n; i++))
do
    read arr[i]
done

max=${arr[0]}
min=${arr[0]}

for ((i=1; i<n; i++))
do
    if [ ${arr[i]} -gt $max ]; then
        max=${arr[i]}
    fi
    
    if [ ${arr[i]} -lt $min ]; then
        min=${arr[i]}
    fi
done

echo "Maximum number: $max"
echo "Minimum number: $min"


---

üü¶ 2Ô∏è‚É£ Palindrome Checking (String)

#!/bin/bash

echo "Enter a string:"
read str

len=${#str}
rev=""

for ((i=len-1; i>=0; i--))
do
    rev="$rev${str:$i:1}"
done

if [ "$str" == "$rev" ]; then
    echo "The string is a palindrome."
else
    echo "The string is not a palindrome."
fi


---

üü¶ 3Ô∏è‚É£ Count Characters and Words of a File

#!/bin/bash

echo "Enter the filename:"
read filename

if [ ! -f "$filename" ]; then
    echo "File does not exist."
    exit 1
fi

while IFS= read -r line
do
    char_count=$(echo -n "$line" | wc -m)
    word_count=$(echo "$line" | wc -w)
    
    echo "Line: $line"
    echo "Number of characters: $char_count"
    echo "Number of words: $word_count"
    echo "-------------------------------------"
done < "$filename"


---

üü¶ 4Ô∏è‚É£ Check Whether Input Is Number or String

#!/bin/bash

echo "Enter a value:"
read input

if [[ "$input" =~ ^[0-9]+$ ]]; then
    echo "$input is a number."
else
    echo "$input is a string."
fi



UNIX

1) Emulate ls -l
SOURCE CODE:
#include <stdio.h>
#include <dir.h>
void main() {
    struct ffblk f;
    int d, yr, mo, dy;
    d = findfirst("*.*", &f, FA_DIREC | FA_ARCH | FA_RDONLY | FA_HIDDEN);
    while (!d) {
        yr = (f.ff_fdate >> 9) + 1980;
        mo = (f.ff_fdate >> 5) & 15;
        dy = f.ff_fdate & 31;
        printf("%c%c%c\t%8ld\t%02d-%02d-%d\t%s\n",
            (f.ff_attrib & FA_DIREC) ? 'd' : '-',
            (f.ff_attrib & FA_RDONLY) ? 'r' : 'w',
            (f.ff_attrib & FA_HIDDEN) ? 'h' : '-',
            f.ff_fsize, dy, mo, yr, f.ff_name);
        d = findnext(&f);
    }
}

OUTPUT:
dw-           0	15-10-2024	INCLUDE
-w-         512	22-12-2025	NONAME00.C
-w-       12050	01-11-2023	PROJECT.EXE
-r-        2048	05-01-2022	README.TXT
dw-           0	10-09-2024	BIN
-wh         128	12-08-2024	SECRET.LOG


5.commands concurrently with a command pipe
SOURCE CODE:
#include<stdio.h>
#include<stdlib.h>
void main()
{
clrscr();
system("dir | sort");
//system("ls -l | sort");
getch();
}

OUTPUT:
2 Dir(s)  20,450,050,123 bytes free
               3 File(s)         15,400 bytes
 Directory of C:\TURBOC3\SOURCE
 Volume Serial Number is A1B2-C3D4
 Volume in drive C has no label.
10-05-2025  09:30 AM               512 INPUT.C
11-15-2025  02:15 PM            12,050 OUTPUT.EXE
12-22-2025  11:11 AM    <DIR>          .
12-22-2025  11:11 AM    <DIR>          ..
12-22-2025  11:12 AM             2,838 SORT.C

6. fork(),wait(),exec()

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main()
{
    pid_t pid;

    pid = fork();

    if (pid < 0)
    {
        printf("Fork failed\n");
        return 1;
    }
    else if (pid == 0)
    {
        execl("/bin/ls", "ls", "-l", NULL);
        printf("Exec failed\n");
    }
    else
    {
        wait(NULL);
        printf("Child finished\n");
    }

    return 0;
}
expected output:
total 12
-rw-r--r-- 1 user user  3456 file1.c
-rw-r--r-- 1 user user  2104 file2.c
drwxr-xr-x 2 user user  4096 folder1
Child finished

